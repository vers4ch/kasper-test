## Обзор

Этот скрипт предназначен для парсинга информации о вендорах, продуктах и уязвимостях с определённых веб-страниц и сохранения данных в базе данных SQLite. Кроме того, скрипт собирает и добавляет теги, связанные с уязвимостями. Для веб-скрапинга используются библиотеки `requests` и `BeautifulSoup`, а для работы с базой данных — `sqlite3`. Скрипт использует многопоточность для эффективного сбора тегов.

## Возможности

- **Управление базой данных:** Создаёт и управляет таблицами SQLite для вендоров, продуктов, уязвимостей и тегов.
- **Веб-скрапинг:** Извлекает данные с threats.kaspersky.com о вендорах, продуктах и уязвимостях.
- **Многопоточность:** Собирает теги, связанные с уязвимостями, используя параллельные потоки для повышения производительности.

## Требования

- Python 3.x
- Библиотека `requests`
- Библиотека `beautifulsoup4`
- Библиотека `sqlite3` (входит в стандартную библиотеку Python)

## Настройка

1. **Установка зависимостей**

   Убедитесь, что все необходимые библиотеки установлены. Вы можете установить их с помощью pip:

   ```bash
   pip install requests beautifulsoup4
   ```

2. **Создание базы данных**

   Скрипт автоматически создаст и управляет базой данных SQLite (`database.db`).

## Использование

1. **Запуск скрипт для сбора данных или пропустите этот шаг, уже собранные данные приложены**

   Запустите скрипт с помощью Python:

   ```bash
   python pars.py
   ```
   Скрипт с 0 парсит всё, что ему требуется 15 минут (тестировалось на Macbook Air M1)


2. **Скрипты сбора данных с бд**

   Запустите скрипт с помощью Python:

   ```bash
   python main.py
   ```
   Скрипт собирает требуемые значения и выводит на экран. Вендора, топ-n, тэг можно изменить в файле main.py


## Функции pars.py

- **`create_vendors_table(conn)`**: Создаёт таблицу `vendors`, если она не существует.
- **`create_products_table(conn)`**: Создаёт таблицу `products`, если она не существует.
- **`create_vulnerabilities_table(conn)`**: Создаёт таблицу `vulnerabilities`, если она не существует.
- **`create_tags_table(conn)`**: Создаёт таблицу `tags`, если она не существует.
- **`get_vendor_id_by_name(conn, name)`**: Получает ID вендора по имени.
- **`get_product_id_by_name(conn, name)`**: Получает ID продукта по имени.
- **`get_vulnerability_id_by_link(conn, link)`**: Получает ID уязвимости по ссылке.
- **`insert_or_update_vendor_data(conn, name, count_products, link)`**: Вставляет или обновляет данные о вендоре.
- **`insert_product_data(conn, name, vendor_id, value, link)`**: Вставляет данные о продукте.
- **`insert_vulnerability_data(conn, name, product_id, link, article_id=0)`**: Вставляет данные об уязвимости.
- **`insert_tag_data(conn, tag, vulnerability_id)`**: Вставляет тег.
- **`parse_vendor_page(url, conn)`**: Парсит страницу с вендорами.
- **`parse_product_page(url, conn)`**: Парсит страницу с продуктами.
- **`parse_vulnerability_page(url, conn)`**: Парсит страницу с уязвимостями.
- **`collect_vulnerability_tags(conn, vulnerability_id, link)`**: С собирает теги для уязвимости.
- **`collect_all_vulnerability_tags(conn)`**: Сбор тегов для всех уязвимостей с использованием многопоточности.
- **`parse_all_pages(base_url, product_base_url, vulnerability_base_url)`**: Основная функция для парсинга всех страниц.

## Примечания
- Скрипт использует многопоточность для сбора тегов, что может потребовать значительных ресурсов на многозадачных системах.
